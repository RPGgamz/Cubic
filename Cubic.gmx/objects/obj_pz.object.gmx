<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initiate
//puzzles
/*
--FORMAT--
solved_pzs = number of solved puzzles (updated in obj_pz_camera_move)
- if this is -1, the zone has been completed

pz[puzzle-number, object]
objects:
0 - id - camera
1 - id - puzzle exit
*/
solved_pzs = 0;

with(obj_camera_zone)
    {
    obj_pz.pz[number-1,0] = id;
    obj_pz.pz[number-1,1] = instance_nearest(x, y, obj_puzzle);
    }
pz[array_height_2d(pz)-1,1] = noone;

//settings
pz_complete_pause = 60;

c_next = ord("E");
c_prev = ord("Q");

//visible walls
with (obj_wall_h)
    {
    visible = true
    sprite_index = spr_wall_h
    }
with (obj_wall_v)
    {
    visible = true
    sprite_index = spr_wall_v
    }


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initiate mini-map
//settings
map_margin = 1;
tile_size = sprite_get_width(spr_pz_map_unsolved); //mb ugly if not factor of height and width of spr_pz_map_tile?
map_alpha = 0.75;

//size ratios between room and map
map_rx = sprite_get_width(spr_camera_zone)/tile_size;
map_ry = sprite_get_height(spr_camera_zone)/tile_size;

//map size
map_width = room_width/map_rx;
map_height = room_height/map_ry;

//top left corner of the map on gui
map_x0 = view_wview[1]-(map_width+map_margin+(obj_display_manager.ideal_width-120)/2);
map_y0 = view_hview[1]-(map_height+map_margin);

map_surf = surface_create(map_width, map_height);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///sound variables
one_to_four = 1;
volume = 33/100;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///update solved_pzs variable
//the timing determines when to change the minimap tile to solved
if instance_exists(obj_pz_camera_move){
    if (obj_pz_camera_move.progress &gt;= 0.5) solved_pzs++;
    else alarm[1]++;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///pz-complete-pause

//afterwards, go to the next puzzle
if (current_puzzle == solved_pzs) {
    scr_pz_goto(solved_pzs+1);
    alarm[1]=1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initiate camera movements
//complete puzzles
if (obj_control.state == scr_move &amp;&amp; instance_exists(pz[current_puzzle,1]) &amp;&amp; scr_pz_complete_check(pz[current_puzzle,1])){
    //pause for sound and animation
    obj_control.state = scr_nothing;
    alarm[0] = pz_complete_pause;
    
    //play "puzzle complete" sound
    if (one_to_four == 1) {
        audio_sound_gain(snd_pc_1, volume, 0);
        audio_play_sound(snd_pc_1, 10, false);
    } else if (one_to_four == 2) {
        audio_sound_gain(snd_pc_2, volume, 0);
        audio_play_sound(snd_pc_2, 10, false);
    } else if (one_to_four == 3) {
        audio_sound_gain(snd_pc_3, volume, 0);
        audio_play_sound(snd_pc_3, 10, false);
    } else if (one_to_four == 4) {
        audio_sound_gain(snd_pc_4, volume, 0);
        audio_play_sound(snd_pc_4, 10, false);
        one_to_four = 0;
    }
    one_to_four++;
    
    //play the animation
    instance_create(0, 0, obj_pz_complete_animation);
}

//Cycle
if (keyboard_check_pressed(vk_anykey) &amp;&amp; alarm[0] == -1)
    {
    switch (keyboard_key)
        {
        case c_next:
            if (instance_exists(pz[current_puzzle,1]) &amp;&amp; (current_puzzle &lt; solved_pzs || solved_pzs == -1)) scr_pz_goto(current_puzzle+1);
            break;
        case c_prev:
            if (0 &lt; current_puzzle) scr_pz_goto(current_puzzle-1);
            break;
        }
    }





</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///reset and leave

//reset puzzle
if (keyboard_check_pressed(ord("R")) &amp;&amp; alarm[0] == -1 &amp;&amp; !instance_exists(obj_pz_camera_move)) scr_puzzle_reset(pz[current_puzzle,0])

//leave puzzle
if (keyboard_check_pressed(vk_escape) &amp;&amp; obj_control.state == scr_idle &amp;&amp; !instance_exists(obj_fade)) {
    var fade = instance_create(0,0,obj_fade);
    fade.alarm[3] = 1;
    fade.this_exit_target_room = obj_zone_exit.target_room;
    fade.this_exit_target_zone = obj_zone_exit.target_zone;
    fade.traveling_cube_lvl = obj_control.traveling_cube_lvl;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy map_surf
surface_free(map_surf);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///go to the next puzzle
if (solved_pzs == -1) current_puzzle = 0;
else current_puzzle = solved_pzs;
var cam = pz[current_puzzle,0];
view_xview[1] = cam.x - view_wview[1]/2;
view_yview[1] = cam.y - view_hview[1]/2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///mini-map

if (!surface_exists(map_surf)) map_surf = surface_create(map_width,map_height);
surface_set_target(map_surf);

//update map
draw_enable_alphablend(false);
draw_clear_alpha(c_black,0);
if (solved_pzs != -1)
    {
    with (obj_camera_zone)
        {
        if (number-1 &gt; obj_pz.solved_pzs)
            {
            draw_sprite(spr_pz_map_unsolved, 0, (x-sprite_width/2)/other.map_rx, (y-sprite_height/2)/other.map_ry);
            continue;
            }
        if (number-1 &lt; obj_pz.solved_pzs)
            { 
            draw_sprite(spr_pz_map_solved, 0, (x-sprite_width/2)/other.map_rx, (y-sprite_height/2)/other.map_ry);
            continue;
            }
        draw_sprite(spr_pz_map_newest, 0, (x-sprite_width/2)/other.map_rx, (y-sprite_height/2)/other.map_ry);
        }
    }
else with (obj_camera_zone) draw_sprite(spr_pz_map_solved, 0, (x-sprite_width/2)/other.map_rx, (y-sprite_height/2)/other.map_ry);
draw_enable_alphablend(true);

//*animated select*/ draw_sprite(spr_pz_map_highlight, 0, (view_xview[1]+(view_wview[1]-sprite_get_width(spr_camera_zone))/2)/map_rx, (view_yview[1]+(view_hview[1]-sprite_get_height(spr_camera_zone))/2)/map_ry);
/*rounded select*/ with instance_nearest(view_xview[1]+view_wview[1]/2, view_yview[1]+view_hview[1]/2,obj_camera_zone) draw_sprite(spr_pz_map_current, 0, (x-sprite_width/2)/other.map_rx, (y-sprite_height/2)/other.map_ry);


surface_reset_target();

//draw the map
draw_set_alpha(map_alpha);
draw_surface(map_surf, map_x0, map_y0)
draw_set_alpha(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
