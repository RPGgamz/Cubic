<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initiate
//settings
res_size = 2; //side length of each square in the effect, in pixels
effect_alpha = 1;
effect_power = 5;
effect_fade = 0.02 //how fast the new ripples get smaller than the first. 0 is not at all, bigger is faster.

ripple_speed = 1.5;
n_ripples = 6;
ripple_width = 15;

//variables
cam = obj_pz.pz[obj_pz.current_puzzle,0];
var pzdoorobj = obj_pz.pz[obj_pz.current_puzzle,1];
var pz_cube = instance_position(pzdoorobj.x, pzdoorobj.y, obj_cube);
x = pz_cube.x;
y = pz_cube.y;;
w = cam.sprite_width
h = cam.sprite_height
surfx = cam.x - w/2
surfy = cam.y - h/2
n_ver_x = round(w/res_size); //number of vertexes along x-axis
n_ver_y = round(h/res_size);
t = 0;
m = 2*n_ripples*ripple_width; //width of the effect in terms of t

surf_start = -1;
surf_effect = -1;

//initiate arrays
var xx = n_ver_x;
repeat (n_ver_x) {
    xx--;
    var yy = n_ver_y;
    repeat (n_ver_y) {
        yy--;
        ver_e[xx, yy] = 0; //the effects power on the specific vertex
        ver_a[xx, yy] = degtorad(point_direction(x-surfx, y-surfy, xx*res_size, yy*res_size)); //the effects angle on the specific vertex
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///make walls visible again
var i = 0;
repeat(array_length_1d(walls)) {
    walls[i].visible = true;
    i++;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///calculate vertex positions

var u = t-m; //distance from center to inner edge of effect "ring"
if (u &gt; w) instance_destroy();

var xx = 0;
repeat (n_ver_x) {
    var yy = 0;
    repeat (n_ver_y) {
        var dist = distance_to_point(surfx+xx*res_size, surfy+yy*res_size)
        if !(u &lt; dist &amp;&amp; dist &lt; t) ver_e[xx, yy] = 0;
        else ver_e[xx, yy] = -sin((dist - t)*pi/ripple_width)*effect_power*exp(effect_fade*(dist-t+0.5*ripple_width));
        yy++;
    }
    xx++;
}

t += ripple_speed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///create surf_start and surf_effect

if (surf_start == -1) {
    surf_start = surface_create(w,h);
    surface_set_target(surf_start);
    draw_clear_alpha(c_white, 0);
    
    var i=0;
    with (obj_solid) {
        if (place_meeting(x, y, other.cam) &amp;&amp; (object_index == obj_wall_v || object_index == obj_wall_h)) {
            draw_sprite(sprite_index, image_index, x-other.surfx, y-other.surfy)
            visible = false;
            other.walls[i] = id;
            i++
        }
    }
    /*with (obj_wall_v) {
        draw_sprite(sprite_index, image_index, x-other.surfx, y-other.surfy)
        draw_sprite(sprite_index, image_index, x-other.surfx, y-other.surfy)
    }*/
    surface_reset_target();
    surf_effect = surface_create(w,h);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw the effect

var ytex = 1/n_ver_y;
var xtex = 1/n_ver_x;

surface_set_target(surf_effect);
draw_clear_alpha(c_white, 0);
draw_set_color(c_white);

var x_offset;
var y_offset;
var yy = 0;
repeat (n_ver_y-1) {
    draw_primitive_begin_texture(pr_trianglestrip, surface_get_texture(surf_start));
    var xx = 0;
    repeat (n_ver_x) {
        x_offset = ver_e[xx, yy]*cos(ver_a[xx, yy]);
        y_offset = -ver_e[xx, yy]*sin(ver_a[xx, yy]);
        draw_vertex_texture(xx*res_size+x_offset,     yy*res_size+y_offset, xx*xtex, yy*ytex);
        y_offset = -ver_e[xx, yy]*sin(ver_a[xx, yy]);
        draw_vertex_texture(xx*res_size+x_offset, (yy+1)*res_size+y_offset, xx*xtex, (yy+1)*ytex);
        xx++;
    }
    draw_primitive_end();
    yy++;
}



surface_reset_target();

draw_set_alpha(effect_alpha);
draw_surface(surf_effect, surfx, surfy);
draw_set_alpha(1);


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
